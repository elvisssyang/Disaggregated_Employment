#
# alldata <- alldata |>
#   select(-Quarter)
#
#
#
# rawdata <- as.matrix(alldata)
# Conduct our multiplier analysis
# The row we set 44 is 4(4 last observations to start forecasting) + 40(10 years horizon of forecasting)
multiraw = matrix(0,44,k)
multiraw[1:4,]=rawdata[(nrow(rawdata)-3):nrow(rawdata),]
multig = matrix(0,44,k)
multilevels = matrix(0,44,k-1) # matrix that saves the evolution of total employment in reaction to 1 percent point shock in each sector
multigrowth = matrix(0,44,k-1) # matrix that saves the evolution of employment growth in reaction to 1 percentage point shock in each sector
for (sector in 1:(k-1)){
for (i in 5:44){
for (j in 1:(k-1)){
multig[i,j]= multig[(i-1),]%*%phi[(2:86),j]
if (i==5 & j==sector) {multig[i,j]=multig[i,j]+1}
}
multiraw[i,1:(k-1)] = multiraw[(i-4),1:(k-1)]*exp(multig[i,1:(k-1)]/100) # The first value is negative means related to this
multiraw[i,k] = sum(multiraw[i,1:(k-1)])
multig[i,k]=100*(log(multiraw[i,k]) - log(multiraw[(i-4),k]))# Fourth difference and convert into percentage change  # PROBLEM: WHY LOG(1) \ne 0
}
multilevels[,sector]=multiraw[,k]
multigrowth[,sector]=multig[,k]   # suspect here will need to select k instead sector
}
View(multigrowth)
colSums(multigrowth)
colCumsums
??colCumsums
mpers = colCumsums(multigrowth[5:44,])/4 #colCumsums() is a function in matrixStats package
View(mpers)
shares=colSums(rawdata[(nrow(rawdata)-3):nrow(rawdata),1:84])/sum(rawdata[(nrow(rawdata)-3):nrow(rawdata),85]) #sector shares estimated like this to eliminate the effect of seasonality
mtplers <- rbind(shares,mpers)
View(alldata)
View(multig)
alldata <- readr::read_csv("ABSemp.csv")  |>
mutate(Quarter = yearquarter(my(Date))) |>
select(-Date)
# Elvis Yang
# June 2022
# This is the program computes the multipliers and contrafactural or scenario forecasting
library(matrixStats)
library(ggplot2)
library(zoo)
library(tidyverse)
library(dplyr)
library(stats)
library(readxl)
library(pracma)
library(tidyverse)
library(lubridate)
library(fpp3)
# Use the updated data between COVID-19
#
alldata <- readr::read_csv("ABSemp.csv")  |>
mutate(Quarter = yearquarter(my(Date))) |>
select(-Date)
alldata <- alldata |>
select(-Quarter)
rawdata <- as.matrix(alldata)
View(alldata)
multiraw = matrix(0,44,k)
multiraw[1:4,]=rawdata[(nrow(rawdata)-3):nrow(rawdata),]
multig = matrix(0,44,k)
alldata <- readr::read_csv("ABSemp.csv")  |>
mutate(Quarter = yearquarter(my(Date))) |>
select(-Date)
alldata <- alldata |>
select(-Quarter)
rawdata <- as.matrix(alldata)
multiraw = matrix(0,44,k)
multiraw[1:4,]=rawdata[(nrow(rawdata)-3):nrow(rawdata),]
k = 85
multiraw = matrix(0,44,k)
multiraw[1:4,]=rawdata[(nrow(rawdata)-3):nrow(rawdata),]
multig = matrix(0,44,k)
multilevels = matrix(0,44,k-1) # matrix that saves the evolution of total employment in reaction to 1 percent point shock in each sector
multigrowth = matrix(0,44,k-1) # matrix that saves the evolution of employment growth in reaction to 1 percentage point shock in each sector
sector = 1
for (i in 5:44){
for (j in 1:(k-1)){
multig[i,j]= multig[(i-1),]%*%phi[(2:86),j]
if (i==5 & j==sector) {multig[i,j]=multig[i,j]+1}
}
multiraw[i,1:(k-1)] = multiraw[(i-4),1:(k-1)]*exp(multig[i,1:(k-1)]/100) # The first value is negative means related to this
multiraw[i,k] = sum(multiraw[i,1:(k-1)])
multig[i,k]=100*(log(multiraw[i,k]) - log(multiraw[(i-4),k]))# Fourth difference and convert into percentage change  # PROBLEM: WHY LOG(1) \ne 0
}
phi <- read.csv("one_lagphi.csv",header=FALSE) %>% as.matrix #estimated parameters produced by MATLAB code
View(phi)
for (i in 5:44){
for (j in 1:(k-1)){
multig[i,j]= multig[(i-1),]%*%phi[(2:86),j]
if (i==5 & j==sector) {multig[i,j]=multig[i,j]+1}
}
multiraw[i,1:(k-1)] = multiraw[(i-4),1:(k-1)]*exp(multig[i,1:(k-1)]/100) # The first value is negative means related to this
multiraw[i,k] = sum(multiraw[i,1:(k-1)])
multig[i,k]=100*(log(multiraw[i,k]) - log(multiraw[(i-4),k]))# Fourth difference and convert into percentage change  # PROBLEM: WHY LOG(1) \ne 0
}
View(multiraw)
View(multiraw)
multiraw[5,] == multiraw[1,]
sum(multiraw[5,])
sum(multiraw[5,1:84])
i = 5
colSums(multiraw[5,1:84])
rowSums(multiraw[5,1:84])
multiraw[5, 1:84]
i = 5
sum(multiraw[i,1:(k-1)])
multiraw[i,1:(k-1)]
??sum
base::sum(multiraw[i,1:(k-1)])
# Elvis Yang
# June 2022
# This is the program computes the multipliers and contrafactural or scenario forecasting
library(matrixStats)
library(ggplot2)
library(zoo)
library(tidyverse)
library(dplyr)
library(stats)
library(readxl)
library(pracma)
library(tidyverse)
library(lubridate)
library(fpp3)
# INPUTS
# y  Time series
#p lags
# varagin There are the(optional) bootstrapping options
# 'parametric'   Draw residuals parametrically from the covariance matrix
# 'bootstrap_with _replacement'  Draw residuals randomly from the empirical residuals
# 'double_bootstrap'   Bias correction boostrap-after -bootstrap
# 'wild_bootstrap' Allws for hetroskedasticity by multiplying by a random variable
alldata <- readr::read_csv("ABSemp.csv")  |>
mutate(Quarter = yearquarter(my(Date))) |>
select(-Date) |>
filter(Quarter <= yearquarter("2019 Q4"))
alldata <- alldata |>
select(-Quarter)
# generate the total amount of the data
rawdata <- as.matrix(alldata) # Remove the NA values due to the loading of the data.
logdata <- log(rawdata)
d4logdata <- 100*(logdata[5:nrow(logdata),]-logdata[1:(nrow(logdata)-4),]) %>% as.matrix()
summary(d4logdata)  # check summary to see if data are read correctly
N=dim(d4logdata)[2]
p=4
lambda=0.2 # shrinkage
maxhor=2 # maximum forecast horizon where we are imposing conditions
# generate the phi of your estimated model
phi <- read.csv("one_lagphi.csv",header=FALSE) %>% as.matrix #estimated parameters produced by MATLAB code
n = nrow(d4logdata)
k = ncol(d4logdata)
# For users, you have to replace the numbers phi if you really want to build up another type of model
# The phi is produced using MATLAB MAIN.m file, please run that file to generate the estimated coefficients.
# Here the phi are divided to give four lags and one constant.
# phi[1,j] for constant, the rest are multiplied by the four lags and do the estimation
rawhat = matrix(0,n,k)
yhat = matrix(0,n,k)
sdiff = matrix(0,n,k)
for (i in 5:n){
for (j in 1:(k-1)){
yhat[i,j]= phi[1,j] + t(d4logdata[(i-1),]) %*% phi[2:86,j]
}
rawhatv = rawdata[(i-4),1:(k-1)] * exp(yhat[i,1:(k-1)]/100) # back transform
yhat[i,k]=100*log(sum(rawhatv)/rawdata[(i-4),k])
rawhat[i,] = rawdata[(i-4),1:k] * exp(yhat[i,1:k]/100)
sdiff[i,] = exp(yhat[i,1:k]/100)
}
# Use the updated data between COVID-19
#
alldata <- readr::read_csv("ABSemp.csv")  |>
mutate(Quarter = yearquarter(my(Date))) |>
select(-Date)
alldata <- alldata |>
select(-Quarter)
rawdata <- as.matrix(alldata)
k = 85
# Conduct our multiplier analysis
# The row we set 44 is 4(4 last observations to start forecasting) + 40(10 years horizon of forecasting)
multiraw = matrix(0,44,k)
multiraw[1:4,]=rawdata[(nrow(rawdata)-3):nrow(rawdata),]
multig = matrix(0,44,k)
multilevels = matrix(0,44,k-1) # matrix that saves the evolution of total employment in reaction to 1 percent point shock in each sector
multigrowth = matrix(0,44,k-1) # matrix that saves the evolution of employment growth in reaction to 1 percentage point shock in each sector
sector = 1
for (i in 5:44){
for (j in 1:(k-1)){
multig[i,j]= multig[(i-1),]%*%phi[(2:86),j]
if (i==5 & j==sector) {multig[i,j]=multig[i,j]+1}
}
multiraw[i,1:(k-1)] = multiraw[(i-4),1:(k-1)]*exp(multig[i,1:(k-1)]/100) # The first value is negative means related to this
multiraw[i,k] = sum(multiraw[i,1:(k-1)])
multig[i,k]=100 * log(multiraw[i,k]/multiraw[(i-4),k])# Fourth difference and convert into percentage change  # PROBLEM: WHY LOG(1) \ne 0
}
multilevels[,sector]=multiraw[,k]
multigrowth[,sector]=multig[,k]   # suspect here will need to select k instead sector
View(multiraw)
sum(c(1,2,3,4))
for (sector in 1:(k-1)){
for (i in 5:44){
for (j in 1:(k-1)){
multig[i,j]= multig[(i-1),]%*%phi[(2:86),j]
if (i==5 & j==sector) {multig[i,j]=multig[i,j]+1}
}
multiraw[i,1:(k-1)] = multiraw[(i-4),1:(k-1)]*exp(multig[i,1:(k-1)]/100) # The first value is negative means related to this
multiraw[i,k] = sum(multiraw[i,1:(k-1)])
multig[i,k]=100 * log(multiraw[i,k]/multiraw[(i-4),k])# Fourth difference and convert into percentage change  # PROBLEM: WHY LOG(1) \ne 0
}
multilevels[,sector]=multiraw[,k]
multigrowth[,sector]=multig[,k]   # suspect here will need to select k instead sector
}
for (sector in 1:(k-1)){
for (i in 5:44){
for (j in 1:(k-1)){
multig[i,j]= multig[(i-1),]%*%phi[(2:86),j]
if (i==5 & j==sector) {multig[i,j]=multig[i,j]+1}
}
multiraw[i,1:(k-1)] = multiraw[(i-4),1:(k-1)]*exp(multig[i,1:(k-1)]/100) # The first value is negative means related to this
multiraw[i,k] = sum(multiraw[i,1:(k-1)])
multig[i,k]=100 * log(multiraw[i,k]/multiraw[(i-4),k])# Fourth difference and convert into percentage change  # PROBLEM: WHY LOG(1) \ne 0
}
multilevels[,sector]=multiraw[,k]
multigrowth[,sector]=multig[,k]   # suspect here will need to select k instead sector
}
for (sector in 1:(k-1)){
for (i in 5:44){
for (j in 1:(k-1)){
multig[i,j]= multig[(i-1),]%*%phi[(2:86),j]
if (i==5 & j==sector) {multig[i,j]=multig[i,j]+1}
}
multiraw[i,1:(k-1)] = multiraw[(i-4),1:(k-1)]*exp(multig[i,1:(k-1)]/100) # The first value is negative means related to this
multiraw[i,k] = sum(multiraw[i,1:(k-1)])
multig[i,k]=100 * log(multiraw[i,k]/multiraw[(i-4),k])# Fourth difference and convert into percentage change  # PROBLEM: WHY LOG(1) \ne 0
}
multilevels[,sector]=multiraw[,k]
multigrowth[,sector]=multig[,k]   # suspect here will need to select k instead sector
}
debugSource("~/Desktop/hon_proj/Disaggregated_Employment/Spilover/forecast_onelag.R", echo=TRUE)
for (sector in 1:(k-1)){
for (i in 5:44){
for (j in 1:(k-1)){
multig[i,j]= multig[(i-1),]%*%phi[(2:86),j]
if (i==5 & j==sector) {multig[i,j]=multig[i,j]+1}
}
multiraw[i,1:(k-1)] = multiraw[(i-4),1:(k-1)]*exp(multig[i,1:(k-1)]/100) # The first value is negative means related to this
multiraw[i,k] = sum(multiraw[i,1:(k-1)])
multig[i,k]=100 * log(multiraw[i,k]/multiraw[(i-4),k])# Fourth difference and convert into percentage change  # PROBLEM: WHY LOG(1) \ne 0
}
multilevels[,sector]=multiraw[,k]
multigrowth[,sector]=multig[,k]   # suspect here will need to select k instead sector
}
# Elvis Yang
# June 2022
# This is the program computes the multipliers and contrafactural or scenario forecasting
library(matrixStats)
library(ggplot2)
library(zoo)
library(tidyverse)
library(dplyr)
library(stats)
library(readxl)
library(pracma)
library(tidyverse)
library(lubridate)
library(fpp3)
# INPUTS
# y  Time series
#p lags
# varagin There are the(optional) bootstrapping options
# 'parametric'   Draw residuals parametrically from the covariance matrix
# 'bootstrap_with _replacement'  Draw residuals randomly from the empirical residuals
# 'double_bootstrap'   Bias correction boostrap-after -bootstrap
# 'wild_bootstrap' Allws for hetroskedasticity by multiplying by a random variable
alldata <- readr::read_csv("ABSemp.csv")  |>
mutate(Quarter = yearquarter(my(Date))) |>
select(-Date) |>
filter(Quarter <= yearquarter("2019 Q4"))
alldata <- alldata |>
select(-Quarter)
# generate the total amount of the data
rawdata <- as.matrix(alldata) # Remove the NA values due to the loading of the data.
logdata <- log(rawdata)
d4logdata <- 100*(logdata[5:nrow(logdata),]-logdata[1:(nrow(logdata)-4),]) %>% as.matrix()
summary(d4logdata)  # check summary to see if data are read correctly
N=dim(d4logdata)[2]
p=4
lambda=0.2 # shrinkage
maxhor=2 # maximum forecast horizon where we are imposing conditions
# generate the phi of your estimated model
phi <- read.csv("one_lagphi.csv",header=FALSE) %>% as.matrix #estimated parameters produced by MATLAB code
n = nrow(d4logdata)
k = ncol(d4logdata)
# For users, you have to replace the numbers phi if you really want to build up another type of model
# The phi is produced using MATLAB MAIN.m file, please run that file to generate the estimated coefficients.
# Here the phi are divided to give four lags and one constant.
# phi[1,j] for constant, the rest are multiplied by the four lags and do the estimation
rawhat = matrix(0,n,k)
yhat = matrix(0,n,k)
sdiff = matrix(0,n,k)
for (i in 5:n){
for (j in 1:(k-1)){
yhat[i,j]= phi[1,j] + t(d4logdata[(i-1),]) %*% phi[2:86,j]
}
rawhatv = rawdata[(i-4),1:(k-1)] * exp(yhat[i,1:(k-1)]/100) # back transform
yhat[i,k]=100*log(sum(rawhatv)/rawdata[(i-4),k])
rawhat[i,] = rawdata[(i-4),1:k] * exp(yhat[i,1:k]/100)
sdiff[i,] = exp(yhat[i,1:k]/100)
}
multiraw = matrix(0,44,k)
multiraw[1:4,]=rawdata[(nrow(rawdata)-3):nrow(rawdata),]
multig = matrix(0,44,k)
multilevels = matrix(0,44,k-1) # matrix that saves the evolution of total employment in reaction to 1 percent point shock in each sector
multigrowth = matrix(0,44,k-1) # matrix that saves the evolution of employment growth in reaction to 1 percentage point shock in each sector
sector = 1
for (i in 5:44){
for (j in 1:(k-1)){
multig[i,j]= multig[(i-1),]%*%phi[(2:86),j]
if (i==5 & j==sector) {multig[i,j]=multig[i,j]+1}
}
multiraw[i,1:(k-1)] = multiraw[(i-4),1:(k-1)]*exp(multig[i,1:(k-1)]/100) # The first value is negative means related to this
multiraw[i,k] = sum(multiraw[i,1:(k-1)])
multig[i,k]=100 * log(multiraw[i,k]/multiraw[(i-4),k])# Fourth difference and convert into percentage change  # PROBLEM: WHY LOG(1) \ne 0
}
View(multiraw)
View(multiraw)
multiraw[5,] == multiraw[1,]
sum(mulitraw[5,1:84])
sum(multiraw[5,1:84])
sum(multiraw[1,1:84])
alldata |>
mutate(Total = rowSums(alldata))
View(alldata)
alldata <-alldata |>
mutate(Total = rowSums(alldata))
View(alldata)
alldata <-alldata |>
select(-`96 Total`) |>
mutate(Total = rowSums(alldata))
alldata <-alldata |>
select(-`96 Total`) |>
mutate(Total = colSums(alldata))
alldata <-alldata |>
select(-`96 Total`) |>
mutate(Total = rowSums(alldata))
alldata <-alldata |>
select(-`96 Total`) |>
mutate(Total = rowSums(alldata))
alldata <-alldata |>
mutate(Total = rowSums(alldata))
sum(alldata[1,1:84])
sum(alldata[2,1:84])
aaa <- rowSums(alldata)
View(aaa)
alldata <- readr::read_csv("ABSemp.csv")  |>
mutate(Quarter = yearquarter(my(Date))) |>
select(-Date) |>
filter(Quarter <= yearquarter("2019 Q4"))
View(alldata)
sum(alldata[,1:84])
sum(alldata[1,1:84])
sum(alldata[2,1:84])
sum(alldata[3,1:84])
sum(alldata[4,1:84])
alldata[1,1]
digits(alldata[1,1])
options(digits = 10)
rowSums(alldata[,1:84])
alldata <- readr::read_csv("ABSemp.csv")  |>
mutate(Quarter = yearquarter(my(Date))) |>
select(-Date) |>
filter(Quarter <= yearquarter("2019 Q4"))
alldata <- alldata |>
select(-Quarter)
alldata <- readr::read_csv("ABSemp.csv")  |>
mutate(Quarter = yearquarter(my(Date))) |>
select(-Date, -`96 Total`) |>
filter(Quarter <= yearquarter("2019 Q4"))
alldata <- readr::read_csv("ABSemp.csv")  |>
mutate(Quarter = yearquarter(my(Date)))
View(alldata)
alldata <- readr::read_csv("ABSemp.csv")  |>
mutate(Quarter = yearquarter(my(Date))) |>
select(-Date, -`96 Total`) |>
filter(Quarter <= yearquarter("2019 Q4"))
alldata <- alldata |>
select(-Quarter)
alldata <- alldata |>
select(-Quarter) |>
mutate(`96 Total` = rowSums[alldata[1,nrow]])
alldata <- readr::read_csv("ABSemp.csv")  |>
mutate(Quarter = yearquarter(my(Date))) |>
select(-Date, -`96 Total`) |>
filter(Quarter <= yearquarter("2019 Q4"))
alldata <- alldata |>
select(-Quarter) |>
mutate(`96 Total` = rowSums[alldata[1,nrow]])
alldata <- readr::read_csv("ABSemp.csv")  |>
mutate(Quarter = yearquarter(my(Date))) |>
select(-Date, -`96 Total`) |>
filter(Quarter <= yearquarter("2019 Q4")) |>
select(-Quarter)
alldata |>
mutate(`96 Total` = rowSums[alldata[,1:ncol(rowSums(alldata))]])
alldata |>
mutate(`96 Total` = rowSums[alldata[,1:ncol(alldata)]])
alldata[,1:ncol(alldata)]
rowSums(alldata[,1:ncol(alldata)])
alldata |>
mutate(`96 Total` = rowSums(alldata[,1:ncol(alldata)]))
# generate the total amount of the data
rawdata <- as.matrix(alldata) # Remove the NA values due to the loading of the data.
logdata <- log(rawdata)
d4logdata <- 100*(logdata[5:nrow(logdata),]-logdata[1:(nrow(logdata)-4),]) %>% as.matrix()
summary(d4logdata)  # check summary to see if data are read correctly
N=dim(d4logdata)[2]
p=4
lambda=0.2 # shrinkage
maxhor=2 # maximum forecast horizon where we are imposing conditions
phi <- read.csv("one_lagphi.csv",header=FALSE) %>% as.matrix #estimated parameters produced by MATLAB code
n = nrow(d4logdata)
k = ncol(d4logdata)
rawhat = matrix(0,n,k)
yhat = matrix(0,n,k)
sdiff = matrix(0,n,k)
for (i in 5:n){
for (j in 1:(k-1)){
yhat[i,j]= phi[1,j] + t(d4logdata[(i-1),]) %*% phi[2:86,j]
}
rawhatv = rawdata[(i-4),1:(k-1)] * exp(yhat[i,1:(k-1)]/100) # back transform
yhat[i,k]=100*log(sum(rawhatv)/rawdata[(i-4),k])
rawhat[i,] = rawdata[(i-4),1:k] * exp(yhat[i,1:k]/100)
sdiff[i,] = exp(yhat[i,1:k]/100)
}
multiraw = matrix(0,44,k)
multiraw[1:4,]=rawdata[(nrow(rawdata)-3):nrow(rawdata),]
multig = matrix(0,44,k)
multilevels = matrix(0,44,k-1) # matrix that saves the evolution of total employment in reaction to 1 percent point shock in each sector
multigrowth = matrix(0,44,k-1) # matrix that saves the evolution of employment growth in reaction to 1 percentage point shock in each sector
for (sector in 1:(k-1)){
for (i in 5:44){
for (j in 1:(k-1)){
multig[i,j]= multig[(i-1),]%*%phi[(2:86),j]
if (i==5 & j==sector) {multig[i,j]=multig[i,j]+1}
}
multiraw[i,1:(k-1)] = multiraw[(i-4),1:(k-1)]*exp(multig[i,1:(k-1)]/100) # The first value is negative means related to this
multiraw[i,k] = sum(multiraw[i,1:(k-1)])
multig[i,k]=100 * log(multiraw[i,k]/multiraw[(i-4),k])# Fourth difference and convert into percentage change  # PROBLEM: WHY LOG(1) \ne 0
}
multilevels[,sector]=multiraw[,k]
multigrowth[,sector]=multig[,k]   # suspect here will need to select k instead sector
}
multipliers = colSums(multigrowth)/4 # division by 4 is necessary because of seasonal differences
mpers = colCumsums(multigrowth[5:44,])/4 #colCumsums() is a function in matrixStats package
shares=colSums(rawdata[(nrow(rawdata)-3):nrow(rawdata),1:84])/sum(rawdata[(nrow(rawdata)-3):nrow(rawdata),85]) #sector shares estimated like this to eliminate the effect of seasonality
mtplers <- rbind(shares,mpers)
shares=colSums(rawdata[(nrow(rawdata)-3):nrow(rawdata),1:84])/sum(rawdata[(nrow(rawdata)-3):nrow(rawdata),85]) #sector shares estimated like this to eliminate the effect of seasonality
# generate the total number
alldata <- alldata |>
mutate(`96 Total` = rowSums(alldata[,1:ncol(alldata)]))
View(alldata)
# generate the total amount of the data
rawdata <- as.matrix(alldata) # Remove the NA values due to the loading of the data.
logdata <- log(rawdata)
d4logdata <- 100*(logdata[5:nrow(logdata),]-logdata[1:(nrow(logdata)-4),]) %>% as.matrix()
summary(d4logdata)  # check summary to see if data are read correctly
N=dim(d4logdata)[2]
p=4
lambda=0.2 # shrinkage
maxhor=2 # maximum forecast horizon where we are imposing conditions
phi <- read.csv("one_lagphi.csv",header=FALSE) %>% as.matrix #estimated parameters produced by MATLAB code
n = nrow(d4logdata)
k = ncol(d4logdata)
rawhat = matrix(0,n,k)
yhat = matrix(0,n,k)
sdiff = matrix(0,n,k)
for (i in 5:n){
for (j in 1:(k-1)){
yhat[i,j]= phi[1,j] + t(d4logdata[(i-1),]) %*% phi[2:86,j]
}
rawhatv = rawdata[(i-4),1:(k-1)] * exp(yhat[i,1:(k-1)]/100) # back transform
yhat[i,k]=100*log(sum(rawhatv)/rawdata[(i-4),k])
rawhat[i,] = rawdata[(i-4),1:k] * exp(yhat[i,1:k]/100)
sdiff[i,] = exp(yhat[i,1:k]/100)
}
multiraw = matrix(0,44,k)
multiraw[1:4,]=rawdata[(nrow(rawdata)-3):nrow(rawdata),]
multig = matrix(0,44,k)
multilevels = matrix(0,44,k-1) # matrix that saves the evolution of total employment in reaction to 1 percent point shock in each sector
multigrowth = matrix(0,44,k-1) # matrix that saves the evolution of employment growth in reaction to 1 percentage point shock in each sector
for (sector in 1:(k-1)){
for (i in 5:44){
for (j in 1:(k-1)){
multig[i,j]= multig[(i-1),]%*%phi[(2:86),j]
if (i==5 & j==sector) {multig[i,j]=multig[i,j]+1}
}
multiraw[i,1:(k-1)] = multiraw[(i-4),1:(k-1)]*exp(multig[i,1:(k-1)]/100) # The first value is negative means related to this
multiraw[i,k] = sum(multiraw[i,1:(k-1)])
multig[i,k]=100 * log(multiraw[i,k]/multiraw[(i-4),k])# Fourth difference and convert into percentage change  # PROBLEM: WHY LOG(1) \ne 0
}
multilevels[,sector]=multiraw[,k]
multigrowth[,sector]=multig[,k]   # suspect here will need to select k instead sector
}
multipliers = colSums(multigrowth)/4 # division by 4 is necessary because of seasonal differences
mpers = colCumsums(multigrowth[5:44,])/4 #colCumsums() is a function in matrixStats package
shares=colSums(rawdata[(nrow(rawdata)-3):nrow(rawdata),1:84])/sum(rawdata[(nrow(rawdata)-3):nrow(rawdata),85]) #sector shares estimated like this to eliminate the effect of seasonality
mtplers <- rbind(shares,mpers)
View(mtplers)
sum(mtplers[1,])
