alldata <- alldata[-150,-c(85:89)]
View(alldata)
alldata <- readr::read_csv("ABSemp.csv")
alldata <- readr::read_csv("ABSemp.csv")
View(alldata)
alldata <- readr::read_csv("ABSemp.csv") %>% na.omit()
library(matrixStats)
library(ggploot2)
library(zoo)
library(tidyverse)
library(dplyr)
library(stats)
alldata <- readr::read_csv("ABSemp.csv") %>% na.omit()
alldata <- readr::read_csv("ABSemp.csv")
View(alldata)
alldata <- readr::read_csv("ABSemp.csv") [-152:]
alldata <- alldata[-152:]
alldata <- alldata[-152,]
View(alldata)
View(test)
alldata <- readr::read_csv("ABSemp.csv")
phi <- read.csv("phi.csv",header=FALSE) #estimated parameters produced by MATLAB code
View(phi)
n = nrow(d4logdata)
k = ncol(d4logdata)
yhat = matrix(0,n,k)
n = nrow(d4logdata)
d4logdata <- 100*(logdata[5:nrow(logdata),]-logdata[1:(nrow(logdata)-4),])
logdata <- log(rawdata)
d4logdata <- 100*(logdata[5:nrow(logdata),]-logdata[1:(nrow(logdata)-4),])
logdata <- log(rawdata)
rawdata <- alldata[-152,]
logdata <- log(rawdata)
d4logdata <- 100*(logdata[5:nrow(logdata),]-logdata[1:(nrow(logdata)-4),])
summary(d4logdata)  # check summary to see if data are read correctly
View(alldata)
rawdata <- alldata[-152,-c(85:89)]
logdata <- log(rawdata)
d4logdata <- 100*(logdata[5:nrow(logdata),]-logdata[1:(nrow(logdata)-4),])
summary(d4logdata)  # check summary to see if data are read correctly
phi <- read.csv("phi.csv",header=FALSE) #estimated parameters produced by MATLAB code
n = nrow(d4logdata)
k = ncol(d4logdata)
yhat = matrix(0,n,k)
View(yhat)
for (i in 5:n){
for (j in 1:(k-1)){
yhat[i,j]= phi[1,j] + d4logdata[(i-1),]%*%phi[(2:21),j] + d4logdata[(i-2),]%*%phi[22:41,j] + d4logdata[(i-3),]%*%phi[42:61,j] + d4logdata[(i-4),]%*%phi[62:81,j]
}
rawhat = rawdata[(i-4),1:(k-1)]*exp(yhat[i,1:(k-1)]/100)
yhat[i,k]=100*log(sum(rawhat)/rawdata[(i-4),k])
}
for (i in 5:n){
for (j in 1:(k-1)){
yhat[i,j]= phi[1,j] + d4logdata[(i-1),]%*%phi[(2:21),j] + d4logdata[(i-2),]%*%phi[22:41,j] + d4logdata[(i-3),]%*%phi[42:61,j] + d4logdata[(i-4),]%*%phi[62:81,j]
}
rawhat = rawdata[(i-4),1:(k-1)]*exp(yhat[i,1:(k-1)]/100)
yhat[i,k]=100*log(sum(rawhat)/rawdata[(i-4),k])
}
for (i in 5:n){
for (j in 1:(k-1)){
yhat[i,j]= phi[1,j] + d4logdata[(i-1),]%*%phi[(2:85),j] + d4logdata[(i-2),]%*%phi[86:169,j] + d4logdata[(i-3),]%*%phi[170:253,j] + d4logdata[(i-4),]%*%phi[254:337,j]
}
rawhat = rawdata[(i-4),1:(k-1)]*exp(yhat[i,1:(k-1)]/100)
yhat[i,k]=100*log(sum(rawhat)/rawdata[(i-4),k])
}
multiraw = matrix(0,44,k)
View(d4logdata)
test<- d4logdata[(i-1),]
View(test)
85 - 2
2:85
count(2:85)
86:169
170:253
254:337
yhat[i,j]= phi[1,j] + d4logdata[(i-1),]%*%phi[(2:85),j] + d4logdata[(i-2),]%*%phi[86:169,j] + d4logdata[(i-3),]%*%phi[170:253,j] + d4logdata[(i-4),]%*%phi[254:337,j]
test2
test<-phi[(2:85),j]
test1<- d4logdata[(i-1),]
View(test1)
yhat[i,j]= phi[1,j] + d4logdata[(i-1),] %*% as.matrix(phi[(2:85),j]) + d4logdata[(i-2), ]%*% as.matrix(phi[86:169,j]) + d4logdata[(i-3),] %*% as.matrix(phi[170:253,j]) + d4logdata[(i-4),] %*% as.matrix(phi[254:337,j])
as.matrix(phi[(2:85),j])
d4logdata[(i-1),]
View(test1)
d4logdata <- 100*(logdata[5:nrow(logdata),]-logdata[1:(nrow(logdata)-4),])
str(d4logdata)
type(d4logdata)
yhat[i,j]= phi[1,j] + t(d4logdata[(i-1),]) %*% as.matrix(phi[(2:85),j]) + t(d4logdata[(i-2), ])%*% as.matrix(phi[86:169,j]) + t(d4logdata[(i-3),]) %*% as.matrix(phi[170:253,j]) + t(d4logdata[(i-4),]) %*% as.matrix(phi[254:337,j])
yhat[i,j]= phi[1,j] + t(d4logdata[(i-1),]) %*% phi[(2:85),j] + t(d4logdata[(i-2), ])%*% phi[86:169,j] + t(d4logdata[(i-3),]) %*% phi[170:253,j] + t(d4logdata[(i-4),]) %*% phi[254:337,j]
View(phi)
yhat[i,j]= phi[1,j] + d4logdata[(i-1),] %*% phi[(2:85),j] + d4logdata[(i-2), ]%*% phi[86:169,j] + d4logdata[(i-3),] %*% phi[170:253,j] + d4logdata[(i-4),] %*% phi[254:337,j]
d4logdata <- 100*(logdata[5:nrow(logdata),]-logdata[1:(nrow(logdata)-4),]) %>% as.matrix()
library(tidyverse)
library(dplyr)
library(stats)
d4logdata <- 100*(logdata[5:nrow(logdata),]-logdata[1:(nrow(logdata)-4),]) %>% as.matrix()
summary(d4logdata)  # check summary to see if data are read correctly
phi <- read.csv("phi.csv",header=FALSE) #estimated parameters produced by MATLAB code
n = nrow(d4logdata)
k = ncol(d4logdata)
yhat = matrix(0,n,k)
# For users, you have to replace the numbers phi if you really want to build up another type of model
# Here the phi are divided to give four lags and one constant.
for (i in 5:n){
for (j in 1:(k-1)){
yhat[i,j]= phi[1,j] + d4logdata[(i-1),] %*% phi[(2:85),j] + d4logdata[(i-2), ]%*% phi[86:169,j] + d4logdata[(i-3),] %*% phi[170:253,j] + d4logdata[(i-4),] %*% phi[254:337,j]
} # calculate the forecast value yhat
rawhat = rawdata[(i-4),1:(k-1)]*exp(yhat[i,1:(k-1)]/100)
yhat[i,k]=100*log(sum(rawhat)/rawdata[(i-4),k])
}   # Forecast the value of the last observation
View(yhat)
View(d4logdata)
# For users, you have to replace the numbers phi if you really want to build up another type of model
# Here the phi are divided to give four lags and one constant.
for (i in 5:n){
for (j in 1:(k-1)){
yhat[i,j]= phi[1,j] + d4logdata[(i-1),] %*% phi[(2:85),j] + d4logdata[(i-2), ]%*% phi[86:169,j] + d4logdata[(i-3),] %*% phi[170:253,j] + d4logdata[(i-4),] %*% phi[254:337,j]
} # calculate the forecast value yhat
rawhat = rawdata[(i-4),1:(k-1)]*exp(yhat[i,1:(k-1)]/100)
yhat[i,k]=100*log(sum(rawhat)/rawdata[(i-4),k]) %>% as.matrix
}   # Forecast the value of the last observation
yhat <- yhat %>% as.matrix()
View(yhat)
library(matrixStats)
library(ggploot2)
library(zoo)
library(tidyverse)
library(dplyr)
library(stats)
alldata <- readr::read_csv("ABSemp.csv")
rawdata <- alldata[-152,-c(85:89)] # Remove the NA values due to the loading of the data.
logdata <- log(rawdata)
d4logdata <- 100*(logdata[5:nrow(logdata),]-logdata[1:(nrow(logdata)-4),]) %>% as.matrix()
summary(d4logdata)  # check summary to see if data are read correctly
phi <- read.csv("phi.csv",header=FALSE) #estimated parameters produced by MATLAB code
n = nrow(d4logdata)
k = ncol(d4logdata)
yhat = matrix(0,n,k)
# For users, you have to replace the numbers phi if you really want to build up another type of model
# Here the phi are divided to give four lags and one constant.
for (i in 5:n){
for (j in 1:(k-1)){
yhat[i,j]= phi[1,j] + d4logdata[(i-1),] %*% phi[(2:85),j] + d4logdata[(i-2), ]%*% phi[86:169,j] + d4logdata[(i-3),] %*% phi[170:253,j] + d4logdata[(i-4),] %*% phi[254:337,j]
} # calculate the forecast value yhat
rawhat = rawdata[(i-4),1:(k-1)]*exp(yhat[i,1:(k-1)]/100)
yhat[i,k]=100*log(sum(rawhat)/rawdata[(i-4),k])
}   # Forecast the value of the last observation
View(yhat)
yhat = matrix(0,n,k)
View(yhat)
clear
cl
c
clc
# Elvis Yang
# June 2022
# This is the program computes the multipliers and contrafactural or scenario forecasting
library(matrixStats)
library(ggploot2)
library(zoo)
library(tidyverse)
library(dplyr)
library(stats)
alldata <- readr::read_csv("ABSemp.csv")
rawdata <- alldata[-152,-c(85:89)] # Remove the NA values due to the loading of the data.
logdata <- log(rawdata)
d4logdata <- 100*(logdata[5:nrow(logdata),]-logdata[1:(nrow(logdata)-4),]) %>% as.matrix()
summary(d4logdata)  # check summary to see if data are read correctly
phi <- read.csv("phi.csv",header=FALSE) #estimated parameters produced by MATLAB code
n = nrow(d4logdata)
k = ncol(d4logdata)
yhat = matrix(0,n,k)
# For users, you have to replace the numbers phi if you really want to build up another type of model
# Here the phi are divided to give four lags and one constant.
for (i in 5:n){
for (j in 1:(k-1)){
yhat[i,j]= phi[1,j] + d4logdata[(i-1),] %*% phi[(2:85),j] + d4logdata[(i-2), ]%*% phi[86:169,j] + d4logdata[(i-3),] %*% phi[170:253,j] + d4logdata[(i-4),] %*% phi[254:337,j]
} # calculate the forecast value yhat
rawhat = rawdata[(i-4),1:(k-1)]*exp(yhat[i,1:(k-1)]/100)
yhat[i,k]=100*log(sum(rawhat)/rawdata[(i-4),k])
}   # Forecast the value of the last observation
yhat[i,j]= phi[1,j] + d4logdata[(i-1),] %*% phi[2:85,j] + d4logdata[(i-2), ]%*% phi[86:169,j] + d4logdata[(i-3),] %*% phi[170:253,j] + d4logdata[(i-4),] %*% phi[254:337,j]
yhat[i,j]= phi[1,j] + d4logdata[(i-1),] %*% phi[c(2:85),j] + d4logdata[(i-2), ]%*% phi[c(86:169),j] + d4logdata[(i-3),] %*% phi[c(170:253),j] + d4logdata[(i-4),] %*% phi[c(254:337),j]
# For users, you have to replace the numbers phi if you really want to build up another type of model
# Here the phi are divided to give four lags and one constant.
for (i in 5:n){
for (j in 1:(k-1)){
yhat[i,j]= phi[1,j] + d4logdata[(i-1),] %*% phi[2:85,j] + d4logdata[(i-2), ]%*% phi[86:169,j] + d4logdata[(i-3),] %*% phi[170:253,j] + d4logdata[(i-4),] %*% phi[254:337,j]
} # calculate the forecast value yhat
rawhat = rawdata[(i-4),1:(k-1)]*exp(yhat[i,1:(k-1)]/100)
yhat[i,k]=100*log(sum(rawhat)/rawdata[(i-4),k])
}   # Forecast the value of the last observation
d4logdata[(i-1),]
test<- d4logdata[(i-1),]
test <- t(d4logdata[(i-1),])
phi[2:85,j]
test2<-phi[2:85,j]
test2<- as.matrix(phi[2:85,j])
phi <- read.csv("phi.csv",header=FALSE) %>% as.matrix #estimated parameters produced by MATLAB code
n = nrow(d4logdata)
k = ncol(d4logdata)
yhat = matrix(0,n,k)
# For users, you have to replace the numbers phi if you really want to build up another type of model
# Here the phi are divided to give four lags and one constant.
for (i in 5:n){
for (j in 1:(k-1)){
yhat[i,j]= phi[1,j] + t(d4logdata[(i-1),]) %*% phi[2:85,j] + d4logdata[(i-2), ]%*% phi[86:169,j] + d4logdata[(i-3),] %*% phi[170:253,j] + d4logdata[(i-4),] %*% phi[254:337,j]
} # calculate the forecast value yhat
rawhat = rawdata[(i-4),1:(k-1)]*exp(yhat[i,1:(k-1)]/100)
yhat[i,k]=100*log(sum(rawhat)/rawdata[(i-4),k])
}   # Forecast the value of the last observation
View(yhat)
t(d4logdata[(i-1),]) %*% phi[2:85,j]
yhat[i,j]= phi[1,j] + t(d4logdata[(i-1),]) %*% phi[2:85,j] + t(d4logdata[(i-2), ])%*% phi[86:169,j] + t(d4logdata[(i-3),]) %*% phi[170:253,j] + t(d4logdata[(i-4),]) %*% phi[254:337,j]
t(d4logdata[(i-4),]) %*% phi[254:337,j]
phi[1,j]
as.vector(phi[1,j])
# For users, you have to replace the numbers phi if you really want to build up another type of model
# Here the phi are divided to give four lags and one constant.
for (i in 5:n){
for (j in 1:(k-1)){
yhat[i,j]= as.vector(phi[1,j]) + t(d4logdata[(i-1),]) %*% phi[2:85,j] + t(d4logdata[(i-2), ])%*% phi[86:169,j] + t(d4logdata[(i-3),]) %*% phi[170:253,j] + t(d4logdata[(i-4),]) %*% phi[254:337,j]
} # calculate the forecast value yhat
rawhat = rawdata[(i-4),1:(k-1)]*exp(yhat[i,1:(k-1)]/100)
yhat[i,k]=100*log(sum(rawhat)/rawdata[(i-4),k])
}   # Forecast the value of the last observation
as.vector(phi[1,j]) + t(d4logdata[(i-1),]) %*% phi[2:85,j] + t(d4logdata[(i-2), ])%*% phi[86:169,j] + t(d4logdata[(i-3),]) %*% phi[170:253,j] + t(d4logdata[(i-4),]) %*% phi[254:337,j]
phi[1,j] + t(d4logdata[(i-1),]) %*% phi[2:85,j] + t(d4logdata[(i-2), ])%*% phi[86:169,j] + t(d4logdata[(i-3),]) %*% phi[170:253,j] + t(d4logdata[(i-4),]) %*% phi[254:337,j]
View(phi)
alldata <- readr::read_csv("ABSemp.csv")
rawdata <- as.matrix(alldata[-152,-c(85:89)]) # Remove the NA values due to the loading of the data.
logdata <- log(rawdata)
d4logdata <- 100*(logdata[5:nrow(logdata),]-logdata[1:(nrow(logdata)-4),]) %>% as.matrix()
summary(d4logdata)  # check summary to see if data are read correctly
phi <- read.csv("phi.csv",header=FALSE) %>% as.matrix #estimated parameters produced by MATLAB code
n = nrow(d4logdata)
k = ncol(d4logdata)
yhat = matrix(0,n,k)
# For users, you have to replace the numbers phi if you really want to build up another type of model
# Here the phi are divided to give four lags and one constant.
for (i in 5:n){
for (j in 1:(k-1)){
yhat[i,j]= phi[1,j] + t(d4logdata[(i-1),]) %*% phi[2:85,j] + t(d4logdata[(i-2), ])%*% phi[86:169,j] + t(d4logdata[(i-3),]) %*% phi[170:253,j] + t(d4logdata[(i-4),]) %*% phi[254:337,j]
} # calculate the forecast value yhat
rawhat = rawdata[(i-4),1:(k-1)]*exp(yhat[i,1:(k-1)]/100)
yhat[i,k]=100*log(sum(rawhat)/rawdata[(i-4),k])
}   # Forecast the value of the last observation
View(yhat)
View(yhat)
View(yhat)
??matrix
?matrix()
matrix(1,2,1)
matrix(0,2,1)
matrix(0,2,1,2)
matrix(0,2,1,1)
matrix(1,2,1,2)
matrix(1,2,1,0)
multiraw[1:4,] = rawdata[(nrow(rawdata)-3):nrow(rawdata),]
multiraw = matrix(0,44,k)
multiraw[1:4,] = rawdata[(nrow(rawdata)-3):nrow(rawdata),]
nrow(rawdata)
151-3
multig = matrix(0,44,k)
View(yhat)
View(yhat)
View(rawdata)
View(rawdata)
View(d4logdata)
error = rawdata - yhat
error = rawdata[-5,] - yhat
View(yhat)
error = rawdata[-4,] - yhat
error = rawdata[-1:4,] - yhat
rawdata[-1:4,]
rawdata[-c(1:4),]
error = rawdata[-c(1:4),] - yhat
View(error)
error <- (rawdata[-c(1:4), ] - yhat)[-c(1:4), ]
View(error)
test<-rawdata[-c(1:4), ]
View(test)
error <- (d4logdata - yhat)
View(error)
error <- (d4logdata - yhat)[-c(1:4), ]
View(error)
error[1,2]
as.vector(error[1,2])
1/2
1:3
for(i in 1:n){
for (j in 1:k){
train_err[i:j] <- 100 * as.vector(error[i,j]) / as.vector(d4logdata[i:j])
}
}
train_err <- matrix(0,n,k)
for(i in 1:n){
for (j in 1:k){
train_err[i:j] <- 100 * as.vector(error[i,j]) / as.vector(d4logdata[i:j])
}
}
for (j in 1:(k-1)){
train_err[i:j] <- 100 * as.vector(error[i,j]) / as.vector(d4logdata[i:j])
}
for(i in 1:n){
for (j in 1:(k-1)){
train_err[i:j] <- 100 * as.vector(error[i,j]) / as.vector(d4logdata[i:j])
}
}
i=1
for(i in 1:n){
for (j in 1:(k-1)){
train_err[i:j] <- 100 * as.vector(error[i,j]) / as.vector(d4logdata[i:j])
}
}
i=1
for(i in 1:(n-4)){
for (j in 1:k){
train_err[i:j] <- 100 * as.vector(error[i,j]) / as.vector(d4logdata[i:j])
}
}
View(train_err)
for(i in 1:(n-4)){
for (j in 1:k){
train_err[i,j] <- 100 * as.vector(error[i,j]) / as.vector(d4logdata[i:j])
}
}
View(train_err)
# Elvis Yang
# June 2022
# This is the program computes the multipliers and contrafactural or scenario forecasting
library(matrixStats)
library(ggploot2)
library(zoo)
library(tidyverse)
library(dplyr)
library(stats)
alldata <- readr::read_csv("ABSemp.csv")
rawdata <- as.matrix(alldata[-152,-c(85:89)]) # Remove the NA values due to the loading of the data.
logdata <- log(rawdata)
d4logdata <- 100*(logdata[5:nrow(logdata),]-logdata[1:(nrow(logdata)-4),]) %>% as.matrix()
summary(d4logdata)  # check summary to see if data are read correctly
phi <- read.csv("phi.csv",header=FALSE) %>% as.matrix #estimated parameters produced by MATLAB code
n = nrow(d4logdata)
k = ncol(d4logdata)
yhat = matrix(0,n,k)
# For users, you have to replace the numbers phi if you really want to build up another type of model
# Here the phi are divided to give four lags and one constant.
# phi[1,j] for constant, the rest are multiplied by the four lags and do the estimation
for (i in 5:n){
for (j in 1:(k-1)){
yhat[i,j]= phi[1,j] + t(d4logdata[(i-1),]) %*% phi[2:85,j] + t(d4logdata[(i-2), ])%*% phi[86:169,j] + t(d4logdata[(i-3),]) %*% phi[170:253,j] + t(d4logdata[(i-4),]) %*% phi[254:337,j]j
} # calculate the forecast value yhat
rawhat = rawdata[(i-4),1:(k-1)]*exp(yhat[i,1:(k-1)]/100)
yhat[i,k]=100*log(sum(rawhat)/rawdata[(i-4),k])
}   # Forecast the value of the last observation
for (i in 5:n){
for (j in 1:(k-1)){
yhat[i,j]= phi[1,j] + t(d4logdata[(i-1),]) %*% phi[2:85,j] + t(d4logdata[(i-2), ])%*% phi[86:169,j] + t(d4logdata[(i-3),]) %*% phi[170:253,j] + t(d4logdata[(i-4),]) %*% phi[254:337,j]j
} # calculate the forecast value yhat
rawhat = rawdata[(i-4),1:(k-1)]*exp(yhat[i,1:(k-1)]/100)
yhat[i,k]=100*log(sum(rawhat)/rawdata[(i-4),k])
}   # Forecast the value of the last observation
for (i in 5:n){
for (j in 1:(k-1)){
yhat[i,j]= phi[1,j] + t(d4logdata[(i-1),]) %*% phi[2:85,j] + t(d4logdata[(i-2), ])%*% phi[86:169,j] + t(d4logdata[(i-3),]) %*% phi[170:253,j] + t(d4logdata[(i-4),]) %*% phi[254:337,j]j
} # calculate the forecast value yhat
rawhat = rawdata[(i-4),1:(k-1)]*exp(yhat[i,1:(k-1)]/100)
yhat[i,k]=100*log(sum(rawhat)/rawdata[(i-4),k])
}   # Forecast the value of the last observation
for (i in 5:n){
for (j in 1:(k-1)){
yhat[i,j]= phi[1,j] + t(d4logdata[(i-1),]) %*% phi[2:85,j] + t(d4logdata[(i-2), ])%*% phi[86:169,j] + t(d4logdata[(i-3),]) %*% phi[170:253,j] + t(d4logdata[(i-4),]) %*% phi[254:337,j]j
} # calculate the forecast value yhat
rawhat = rawdata[(i-4),1:(k-1)]*exp(yhat[i,1:(k-1)]/100)
yhat[i,k]=100*log(sum(rawhat)/rawdata[(i-4),k])
}   # Forecast the value of the last observation
for (i in 5:n){
for (j in 1:(k-1)){
yhat[i,j]= phi[1,j] + t(d4logdata[(i-1),]) %*% phi[2:85,j] + t(d4logdata[(i-2), ])%*% phi[86:169,j] + t(d4logdata[(i-3),]) %*% phi[170:253,j] + t(d4logdata[(i-4),]) %*% phi[254:337,j]j
} # calculate the forecast value yhat
rawhat = rawdata[(i-4),1:(k-1)] * exp(yhat[i,1:(k-1)]/100)
yhat[i,k]=100*log(sum(rawhat)/rawdata[(i-4),k])
}   # Forecast the value of the last observation
for (i in 5:n){
for (j in 1:(k-1)){
yhat[i,j]= phi[1,j] + t(d4logdata[(i-1),]) %*% phi[2:85,j] + t(d4logdata[(i-2), ])%*% phi[86:169,j] + t(d4logdata[(i-3),]) %*% phi[170:253,j] + t(d4logdata[(i-4),]) %*% phi[254:337,j]j
} # calculate the forecast value yhat
rawhat = rawdata[(i-4),1:(k-1)] * exp(yhat[i,1:(k-1)]/100)
yhat[i,k]=100*log(sum(rawhat)/rawdata[(i-4),k])
}   # Forecast the value of the last observation
for (i in 5:n){
for (j in 1:(k-1)){
yhat[i,j]= phi[1,j] + t(d4logdata[(i-1),]) %*% phi[2:85,j] + t(d4logdata[(i-2), ]) %*% phi[86:169,j] + t(d4logdata[(i-3),]) %*% phi[170:253,j] + t(d4logdata[(i-4),]) %*% phi[254:337,j]j
}
rawhat = rawdata[(i-4),1:(k-1)] * exp(yhat[i,1:(k-1)]/100)
yhat[i,k]=100*log(sum(rawhat)/rawdata[(i-4),k])
}
for (i in 5:n){
for (j in 1:(k-1)){
yhat[i,j]= phi[1,j] + t(d4logdata[(i-1),]) %*% phi[2:85,j] + t(d4logdata[(i-2), ]) %*% phi[86:169,j] + t(d4logdata[(i-3),]) %*% phi[170:253,j] + t(d4logdata[(i-4),]) %*% phi[254:337,j]j
} # calculate the forecast value yhat
rawhat = rawdata[(i-4),1:(k-1)] * exp(yhat[i,1:(k-1)]/100)
yhat[i,k]=100*log(sum(rawhat)/rawdata[(i-4),k])
}   # Forecast the value of the last observation
for (i in 5:n){
for (j in 1:(k-1)){
yhat[i,j]= phi[1,j] + t(d4logdata[(i-1),]) %*% phi[2:85,j] + t(d4logdata[(i-2), ]) %*% phi[86:169,j] + t(d4logdata[(i-3),]) %*% phi[170:253,j] + t(d4logdata[(i-4),]) %*% phi[254:337,j]j
} # calculate the forecast value yhat
rawhat = rawdata[(i-4),1:(k-1)] * exp(yhat[i,1:(k-1)]/100)
yhat[i,k]=100*log(sum(rawhat)/rawdata[(i-4),k])
}
yhat[i,j]= phi[1,j] + t(d4logdata[(i-1),]) %*% phi[2:85,j] + t(d4logdata[(i-2), ]) %*% phi[86:169,j] + t(d4logdata[(i-3),]) %*% phi[170:253,j] + t(d4logdata[(i-4),]) %*% phi[254:337,j]
for (i in 5:n){
for (j in 1:(k-1)){
yhat[i,j]= phi[1,j] + t(d4logdata[(i-1),]) %*% phi[2:85,j] + t(d4logdata[(i-2), ]) %*% phi[86:169,j] + t(d4logdata[(i-3),]) %*% phi[170:253,j] + t(d4logdata[(i-4),]) %*% phi[254:337,]
}
rawhat = rawdata[(i-4),1:(k-1)] * exp(yhat[i,1:(k-1)]/100)
yhat[i,k]=100*log(sum(rawhat)/rawdata[(i-4),k])
}
for (i in 5:n){
for (j in 1:(k-1)){
yhat[i,j]= phi[1,j] + t(d4logdata[(i-1),]) %*% phi[2:85,j] + t(d4logdata[(i-2), ]) %*% phi[86:169,j] + t(d4logdata[(i-3),]) %*% phi[170:253,j] + t(d4logdata[(i-4),]) %*% phi[254:337,]
}
rawhat = rawdata[(i-4),1:(k-1)] * exp(yhat[i,1:(k-1)]/100)
yhat[i,k]=100*log(sum(rawhat)/rawdata[(i-4),k])
}
for (i in 5:n){
for (j in 1:(k-1)){
yhat[i,j]= phi[1,j] + t(d4logdata[(i-1),]) %*% phi[2:85,j] + t(d4logdata[(i-2), ]) %*% phi[86:169,j] + t(d4logdata[(i-3),]) %*% phi[170:253,j] + t(d4logdata[(i-4),]) %*% phi[254:337,]
}
rawhat = rawdata[(i-4),1:(k-1)] * exp(yhat[i,1:(k-1)]/100)
yhat[i,k]=100*log(sum(rawhat)/rawdata[(i-4),k])
}
for (i in 5:n){
for (j in 1:(k-1)){
yhat[i,j]= phi[1,j] + t(d4logdata[(i-1),]) %*% phi[2:85,j] + t(d4logdata[(i-2), ]) %*% phi[86:169,j] + t(d4logdata[(i-3),]) %*% phi[170:253,j] + t(d4logdata[(i-4),]) %*% phi[254:337,]
}
rawhat = rawdata[(i-4),1:(k-1)] * exp(yhat[i,1:(k-1)]/100)
yhat[i,k]=100*log(sum(rawhat)/rawdata[(i-4),k])
}
for (i in 5:n){
for (j in 1:(k-1)){
yhat[i,j]= phi[1,j] + t(d4logdata[(i-1),]) %*% phi[2:85,j] + t(d4logdata[(i-2), ]) %*% phi[86:169,j] + t(d4logdata[(i-3),]) %*% phi[170:253,j] + t(d4logdata[(i-4),]) %*% phi[254:337,]
}
rawhat = rawdata[(i-4),1:(k-1)] * exp(yhat[i,1:(k-1)]/100)
yhat[i,k]=100*log(sum(rawhat)/rawdata[(i-4),k])
}
yhat[i,j]= phi[1,j] + t(d4logdata[(i-1),]) %*% phi[2:85,j] + t(d4logdata[(i-2),])%*%phi[86:169,j] + t(d4logdata[(i-3),]) %*% phi[170:253,j] + t(d4logdata[(i-4),]) %*% phi[254:337,]
yhat[i,j]= phi[1,j] + t(d4logdata[(i-1),]) %*% phi[2:85,j] + t(d4logdata[(i-2),]) %*% phi[86:169,j] + t(d4logdata[(i-3),]) %*% phi[170:253,j] + t(d4logdata[(i-4),]) %*%
phi[254:337,j]
for (j in 1:(k-1)){
yhat[i,j]= phi[1,j] + t(d4logdata[(i-1),]) %*% phi[2:85,j] + t(d4logdata[(i-2),]) %*% phi[86:169,j] + t(d4logdata[(i-3),]) %*% phi[170:253,j] + t(d4logdata[(i-4),]) %*%
phi[254:337,j]
}
rawhat = rawdata[(i-4),1:(k-1)] * exp(yhat[i,1:(k-1)]/100)
yhat[i,k]=100*log(sum(rawhat)/rawdata[(i-4),k])
View(yhat)
for (i in 5:n){
for (j in 1:(k-1)){
yhat[i,j]= phi[1,j] + t(d4logdata[(i-1),]) %*% phi[2:85,j] + t(d4logdata[(i-2),]) %*% phi[86:169,j] + t(d4logdata[(i-3),]) %*% phi[170:253,j] + t(d4logdata[(i-4),]) %*%
phi[254:337,j]
}
rawhat = rawdata[(i-4),1:(k-1)] * exp(yhat[i,1:(k-1)]/100)
yhat[i,k]=100*log(sum(rawhat)/rawdata[(i-4),k])
}
View(yhat)
error <- (d4logdata - yhat)[-c(1:4), ]
train_err <- matrix(0,n,k)
for(i in 1:(n-4)){
for (j in 1:k){
train_err[i,j] <- 100 * as.vector(error[i,j]) / as.vector(d4logdata[i,j])
}
}
View(train_err)
4:7
for(i in 1:(n-4)){
for (j in 1:k){
train_err[i,j] <- 100 * as.vector(error[i,j]) / as.vector((d4logdata[-c(1:4),])[i,j])
}
}
View(train_err)
(d4logdata[-c(1:4),])
test<-(d4logdata[-c(1:4),])
View(test)
test <- exp(yhat)
View(test)
error <- (d4logdata - yhat)[-c(1:4), ]
library(matrixStats)
library(ggploot2)
library(zoo)
library(tidyverse)
library(dplyr)
library(stats)
alldata <- readr::read_csv("ABSemp.csv")
rawdata <- as.matrix(alldata[-152,-c(85:89)]) # Remove the NA values due to the loading of the data.
logdata <- log(rawdata)
d4logdata <- 100*(logdata[5:nrow(logdata),]-logdata[1:(nrow(logdata)-4),]) %>% as.matrix()
summary(d4logdata)  # check summary to see if data are read correctly
phi <- read.csv("phi.csv",header=FALSE) %>% as.matrix #estimated parameters produced by MATLAB code
n = nrow(d4logdata)
k = ncol(d4logdata)
yhat = matrix(0,n,k)
for (i in 5:n){
for (j in 1:(k-1)){
yhat[i,j]= phi[1,j] + t(d4logdata[(i-1),]) %*% phi[2:85,j] + t(d4logdata[(i-2),]) %*% phi[86:169,j] + t(d4logdata[(i-3),]) %*% phi[170:253,j] + t(d4logdata[(i-4),]) %*%
phi[254:337,j]
}
rawhat = rawdata[(i-4),1:(k-1)] * exp(yhat[i,1:(k-1)]/100)
yhat[i,k]=100*log(sum(rawhat)/rawdata[(i-4),k])
}
